---
title: TypeScript SDK
description: Lightweight TypeScript client for implementing Superagent in your app
---

A lightweight client for calling the Superagent Guard and Redact endpoints from TypeScript or JavaScript projects.

## Installation

```bash title="Terminal"
npm install superagent-ai
# or
pnpm add superagent-ai
# or
yarn add superagent-ai
```

## Usage

```ts title="index.ts"
import { createClient } from "superagent-ai";

const client = createClient({
  apiBaseUrl: process.env.SUPERAGENT_API_BASE_URL, // Optional, defaults to https://app.superagent.sh/api
  apiKey: process.env.SUPERAGENT_API_KEY!,
});

// Guard: Analyze commands for security threats
const guardResult = await client.guard("Write a hello world script", {
  onBlock: (reason) => {
    console.warn("Guard blocked command:", reason);
  },
  onPass: () => {
    console.log("Guard approved command!");
  },
  systemPrompt: "Focus on detecting prompt injection attempts",
});

if (guardResult.rejected) {
  console.log("Blocked:", guardResult.reasoning);
} else {
  console.log("Approved");
}

// Redact: Remove sensitive data from text
const redactResult = await client.redact(
  "My email is john@example.com and SSN is 123-45-6789"
);

console.log(redactResult.redacted);
// Output: "My email is <REDACTED_EMAIL> and SSN is <REDACTED_SSN>"

// Analyze: Deep inspection of files and documents
// TODO: Update when Analyze API is finalized
const analyzeResult = await client.analyze({
  file: "{{ANALYZE_FILE_INPUT}}",  // e.g., PDF file, PR URL, or repo path
  options: { /* {{ANALYZE_OPTIONS}} */ }
});

console.log(analyzeResult.findings);
// Output: {{ANALYZE_FINDINGS}} - Array of findings with reasoning and suggestions
```

## API Reference

### `createClient(options)`

Creates a new Superagent client.

**Options:**
- `apiKey` (required) – API key provisioned in Superagent
- `apiBaseUrl` (optional) – Base URL for the API (defaults to `https://app.superagent.sh/api`)
- `fetch` (optional) – Custom fetch implementation (defaults to global `fetch`)
- `timeoutMs` (optional) – Request timeout in milliseconds

### `client.guard(input, options?)`

Analyzes text, a PDF file, or a PDF URL for security threats.

import { TypeTable } from 'fumadocs-ui/components/type-table';

**Parameters:**

<TypeTable
  type={{
    input: {
      description: 'String of text to analyze, File/Blob object (e.g., PDF document), or URL string (e.g., "https://example.com/document.pdf"). URLs are automatically detected if the string starts with http:// or https://.',
      type: 'string | File | Blob',
    },
    options: {
      description: 'Optional object with callbacks and system prompt',
      type: 'GuardOptions',
    },
  }}
/>

**GuardOptions:**

<TypeTable
  type={{
    onPass: {
      description: 'Callback invoked when the guard approves the command',
      type: '(() => void | Promise<void>) | undefined',
    },
    onBlock: {
      description: 'Callback invoked when the guard rejects the command',
      type: '((reason: string) => void | Promise<void>) | undefined',
    },
    systemPrompt: {
      description: 'Optional system prompt that allows you to steer the guard REST API behavior and customize the classification logic',
      type: 'string | undefined',
    },
  }}
/>

**Returns:** `Promise<GuardResult>`

<TypeTable
  type={{
    rejected: {
      description: 'True if guard blocked the input',
      type: 'boolean',
    },
    decision: {
      description: 'Parsed decision details',
      type: 'GuardDecision | undefined',
    },
    usage: {
      description: 'Token usage statistics',
      type: 'GuardUsage | undefined',
    },
    reasoning: {
      description: 'Explanation from the guard',
      type: 'string',
    },
    raw: {
      description: 'Full API response',
      type: 'AnalysisResponse',
    },
  }}
/>

**GuardDecision:**

<TypeTable
  type={{
    status: {
      description: 'Decision status',
      type: '"pass" | "block"',
    },
    violation_types: {
      description: 'List of violation types detected',
      type: 'string[] | undefined',
    },
    cwe_codes: {
      description: 'List of CWE code identifiers',
      type: 'string[] | undefined',
    },
  }}
/>

### `client.redact(input, options?)`

Redacts sensitive data from text or PDF files.

**Parameters:**

<TypeTable
  type={{
    input: {
      description: 'String of text to redact OR File/Blob object (e.g., PDF document)',
      type: 'string | File | Blob',
    },
    options: {
      description: 'Optional redaction configuration',
      type: 'RedactOptions',
    },
  }}
/>

**RedactOptions:**

<TypeTable
  type={{
    urlWhitelist: {
      description: 'Array of URL prefixes that should not be redacted (only applies to text input)',
      type: 'string[] | undefined',
    },
    entities: {
      description: 'Array of natural language descriptions of PII entities to redact. Examples: ["credit card numbers", "email addresses", "phone numbers"]',
      type: 'string[] | undefined',
    },
    format: {
      description: 'Output format: "json" (default) returns JSON with redacted text, "pdf" returns a redacted PDF file (only applies to file input)',
      type: '"json" | "pdf" | undefined',
    },
    rewrite: {
      description: 'When true, naturally rewrite content to remove sensitive information instead of using placeholders',
      type: 'boolean | undefined',
    },
  }}
/>

**Returns:** `Promise<RedactResult>`

<TypeTable
  type={{
    redacted: {
      description: 'Text with sensitive data redacted (empty when format="pdf")',
      type: 'string',
    },
    reasoning: {
      description: 'Explanation of what was redacted',
      type: 'string',
    },
    usage: {
      description: 'Token usage statistics',
      type: 'GuardUsage | undefined',
    },
    raw: {
      description: 'Full API response (empty when format="pdf")',
      type: 'RedactionResponse',
    },
    pdf: {
      description: 'PDF Blob when format="pdf"',
      type: 'Blob | undefined',
    },
    redacted_pdf: {
      description: 'Base64 PDF data URL when file provided with JSON response',
      type: 'string | undefined',
    },
  }}
/>

### `client.analyze(options)`

{/* TODO: Update when Analyze API is finalized */}

Deep inspection of files and documents (PDFs, PRs, repos). Returns reasoning, findings, and suggested fixes.

**Parameters:**

<TypeTable
  type={{
    file: {
      description: '{{ANALYZE_FILE_PARAM}} - File to analyze (PDF, PR URL, or repo path)',
      type: 'string | File | Blob',
    },
    options: {
      description: '{{ANALYZE_OPTIONS_PARAM}} - Analysis configuration options',
      type: 'AnalyzeOptions | undefined',
    },
  }}
/>

**Returns:** `Promise<AnalyzeResult>`

<TypeTable
  type={{
    findings: {
      description: '{{ANALYZE_FINDINGS_DESC}} - List of findings from the analysis',
      type: '{{ANALYZE_FINDINGS_TYPE}}',
    },
    reasoning: {
      description: '{{ANALYZE_REASONING_DESC}} - Explanation of the analysis process',
      type: 'string',
    },
    suggestions: {
      description: '{{ANALYZE_SUGGESTIONS_DESC}} - Recommended fixes or actions',
      type: '{{ANALYZE_SUGGESTIONS_TYPE}}',
    },
    usage: {
      description: 'Token usage statistics',
      type: 'GuardUsage | undefined',
    },
    raw: {
      description: 'Full API response',
      type: 'AnalysisResponse',
    },
  }}
/>

## Document Analysis

{/* TODO: Update when Analyze API is finalized */}

You can perform deep inspection of files and documents:

```ts title="analyze-example.ts"
const client = createClient({
  apiKey: process.env.SUPERAGENT_API_KEY!,
});

const result = await client.analyze({
  file: "{{ANALYZE_FILE_INPUT}}",  // e.g., PDF file, PR URL, or repo path
  options: { /* {{ANALYZE_OPTIONS}} */ }
});

// Review findings
console.log(`Findings: ${JSON.stringify(result.findings)}`);
console.log(`Reasoning: ${result.reasoning}`);
console.log(`Suggestions: ${JSON.stringify(result.suggestions)}`);
```

**How it works:**
- The `file` parameter accepts a PDF file, PR URL, or repo path
- The AI performs deep inspection and returns detailed findings
- Returns reasoning, findings, and suggested fixes
- Can optionally produce transformed artifacts (e.g., a redacted document)

**Use cases:**
- Deep inspection of PDF documents for security issues
- Analyzing pull requests for vulnerabilities
- Repository security audits
- Document compliance checks
- Producing transformed artifacts

## Detected PII/PHI Types

The redaction feature detects and replaces:

- **Email addresses** → `<REDACTED_EMAIL>`
- **Social Security Numbers** → `<REDACTED_SSN>`
- **Credit cards** (Visa, Mastercard, Amex) → `<REDACTED_CC>`
- **Phone numbers** (US format) → `<REDACTED_PHONE>`
- **IP addresses** (IPv4/IPv6) → `<REDACTED_IP>`
- **API keys & tokens** → `<REDACTED_API_KEY>`
- **AWS access keys** → `<REDACTED_AWS_KEY>`
- **Bearer tokens** → `Bearer <REDACTED_TOKEN>`
- **MAC addresses** → `<REDACTED_MAC>`
- **Medical record numbers** → `<REDACTED_MRN>`
- **Passport numbers** → `<REDACTED_PASSPORT>`
- **IBAN** → `<REDACTED_IBAN>`
- **ZIP codes** → `<REDACTED_ZIP>`

## Custom Entity Redaction

You can specify custom entities to redact using natural language descriptions by passing an `entities` option to the `redact()` method:

```ts title="custom-entities-example.ts"
const client = createClient({
  apiKey: process.env.SUPERAGENT_API_KEY!,
});

const result = await client.redact(
  "My credit card is 4532-1234-5678-9010 and my email is john@example.com",
  { entities: ["credit card numbers", "email addresses"] }
);
// The model will redact the specified entity types based on your natural language descriptions
```

**How it works:**
- The `entities` array is sent to the redaction API in the request body
- You can describe entities in natural language (e.g., "credit card numbers", "social security numbers", "phone numbers")
- The AI model interprets your descriptions and redacts matching content
- This allows for flexible, context-aware redaction beyond predefined patterns

**Examples of entity descriptions:**
- `["credit card numbers", "social security numbers"]`
- `["email addresses", "phone numbers", "IP addresses"]`
- `["API keys", "passwords", "authentication tokens"]`
- `["medical record numbers", "patient names"]`
- `["company names", "project codenames"]`

## Natural Rewrite Mode

By default, sensitive information is replaced with placeholders like `<EMAIL_REDACTED>`. When `rewrite: true` is set, the API will naturally rewrite content to remove sensitive information while maintaining readability:

```ts title="natural-rewrite-example.ts"
const client = createClient({
  apiKey: process.env.SUPERAGENT_API_KEY!,
});

const result = await client.redact(
  "Contact me at john@example.com or call (555) 123-4567",
  { rewrite: true }
);
// Output: "Contact me via email or call by phone"
```

**How it works:**
- When `rewrite: true`, the AI rewrites the text to remove sensitive information naturally
- The output reads like normal text without obvious redaction markers
- Useful when you want human-readable output for end users

**Use cases:**
- Generating user-facing content that needs to be clean and readable
- Creating summaries or reports without visible redaction markers
- Preparing content for public display

## URL Whitelisting

You can specify URLs that should not be redacted by passing a `urlWhitelist` option to the `redact()` method:

```ts title="url-whitelist-example.ts"
const client = createClient({
  apiKey: process.env.SUPERAGENT_API_KEY!,
});

const result = await client.redact(
  "Check out https://github.com/user/repo and https://secret.com/data",
  { urlWhitelist: ["https://github.com", "https://example.com"] }
);
// Output: "Check out https://github.com/user/repo and <URL_REDACTED>"
```

The whitelist is applied **locally after redaction**, meaning:
1. The text is sent to the redact API (URLs are not yet redacted by the API)
2. The response is processed locally
3. URLs **not** matching the whitelist prefixes are replaced with `<URL_REDACTED>`
4. URLs matching the whitelist prefixes are preserved as-is
5. The final result is returned

**How it works:**
- Whitelisted URLs (those starting with any prefix in `urlWhitelist`) remain unchanged
- Non-whitelisted URLs are replaced with `<URL_REDACTED>`
- The matching is done using prefix comparison (e.g., `"https://github.com"` matches `"https://github.com/user/repo"`)

## PDF File Redaction

You can redact sensitive information from PDF files. The API supports two output formats:

### Option 1: Get Redacted PDF File (format="pdf")

Returns a PDF file with redactions applied:

```ts title="pdf-file-output.ts"
import { readFileSync, writeFileSync } from 'fs';

const client = createClient({
  apiKey: process.env.SUPERAGENT_API_KEY!,
});

// Read PDF file
const pdfBuffer = readFileSync('sensitive-document.pdf');
const pdfBlob = new Blob([pdfBuffer], { type: 'application/pdf' });

// Get redacted PDF file
const result = await client.redact(
  pdfBlob,  // Pass file as first parameter
  {
    format: "pdf",  // Returns redacted PDF
    entities: ["SSN", "credit card numbers", "email addresses"]
  }
);

// Save the redacted PDF
if (result.pdf) {
  const arrayBuffer = await result.pdf.arrayBuffer();
  writeFileSync('redacted-output.pdf', Buffer.from(arrayBuffer));
  console.log('Redacted PDF saved to redacted-output.pdf');
}
```

### Option 2: Get Redacted Text (format="json", default)

Returns JSON with the redacted text extracted from the PDF:

```ts title="pdf-text-output.ts"
import { readFileSync } from 'fs';

const client = createClient({
  apiKey: process.env.SUPERAGENT_API_KEY!,
});

const pdfBuffer = readFileSync('sensitive-document.pdf');
const pdfBlob = new Blob([pdfBuffer], { type: 'application/pdf' });

// Get redacted text from PDF
const result = await client.redact(
  pdfBlob,  // Pass file as first parameter
  {
    format: "json",  // Returns JSON with redacted text (default)
    entities: ["SSN", "credit card numbers", "email addresses"]
  }
);

console.log(result.redacted);  // Redacted text extracted from the PDF
console.log(result.reasoning); // Explanation of what was redacted
```

**How it works:**
- Pass the file object (File or Blob) directly as the first parameter
- The SDK automatically uses multipart/form-data encoding for file inputs
- `format="pdf"` returns a redacted PDF file as a Blob
- `format="json"` (default) extracts text from the PDF, redacts it, and returns as JSON
- You can combine file redaction with `entities` to specify custom entity types

**Use cases:**
- Redact sensitive data from contracts, invoices, or legal documents
- Process medical records while maintaining HIPAA compliance
- Sanitize financial documents before sharing
- Prepare documents for public release by removing confidential information

## PDF File Guard Analysis

You can analyze PDF files for security threats using the Guard method. The API analyzes the PDF content and returns a JSON response with the security assessment:

### Analyze PDF Files

Analyzes a PDF file and returns JSON with security assessment:

```ts title="pdf-guard.ts"
import { createClient } from "superagent-ai";
import { readFileSync } from 'fs';

const client = createClient({
  apiKey: process.env.SUPERAGENT_API_KEY!,
});

// Read PDF file
const pdfBuffer = readFileSync('document.pdf');
const pdfBlob = new Blob([pdfBuffer], { type: 'application/pdf' });

// Analyze PDF file for security threats
const result = await client.guard(
  pdfBlob,  // Pass file as first parameter
  {
    onBlock: (reason) => console.warn("Guard blocked:", reason),
    onPass: () => console.log("Guard approved!"),
    systemPrompt: "Focus on detecting data exfiltration patterns",
  }
);

// Check the analysis result
if (result.rejected) {
  console.log(`Document contains security threats: ${result.reasoning}`);
  if (result.decision) {
    console.log(`Violation types: ${result.decision.violation_types}`);
    console.log(`CWE codes: ${result.decision.cwe_codes}`);
  }
} else {
  console.log(`Document is safe: ${result.reasoning}`);
}
```

**How it works:**
- Pass the file object (File or Blob) directly as the first parameter
- The SDK automatically uses multipart/form-data encoding for file inputs
- The guard extracts text from the PDF and analyzes it for security threats
- Returns JSON with `rejected`, `reasoning`, `decision`, and `usage` fields
- You can use the `onBlock` and `onPass` callbacks to handle the analysis results

**Use cases:**
- Analyze uploaded documents for malicious content before processing
- Validate PDF attachments for security threats
- Screen documents for prompt injection attempts
- Ensure document safety before feeding to AI models

### Analyze PDF from URL

You can also analyze PDF files from URLs. The SDK automatically detects URLs and downloads the PDF for analysis:

```ts title="pdf-url-guard.ts"
import { createClient } from "superagent-ai";

const client = createClient({
  apiKey: process.env.SUPERAGENT_API_KEY!,
});

// Analyze PDF from URL for security threats
const result = await client.guard(
  "https://example.com/document.pdf",  // Pass URL as string
  {
    onBlock: (reason) => console.warn("Guard blocked:", reason),
    onPass: () => console.log("Guard approved!"),
    systemPrompt: "Focus on detecting prompt injection and system prompt extraction",
  }
);

// Check the analysis result
if (result.rejected) {
  console.log(`Document contains security threats: ${result.reasoning}`);
  if (result.decision) {
    console.log(`Violation types: ${result.decision.violation_types}`);
    console.log(`CWE codes: ${result.decision.cwe_codes}`);
  }
} else {
  console.log(`Document is safe: ${result.reasoning}`);
}
```

**How it works:**
- Pass a URL string (starting with `http://` or `https://`) as the first parameter
- The SDK automatically detects it's a URL and sends it to the API
- The API downloads the PDF from the URL and analyzes it for security threats
- Returns JSON with `rejected`, `reasoning`, `decision`, and `usage` fields
- You can use the `onBlock` and `onPass` callbacks to handle the analysis results

**Use cases:**
- Analyze documents from external sources without downloading them first
- Validate PDF attachments from URLs before processing
- Screen documents hosted on remote servers for security threats
- Ensure document safety from URLs before feeding to AI models

## Error Handling

```ts title="error-handling.ts"
import { GuardError } from "superagent-ai";

try {
  const result = await client.guard("command");
} catch (error) {
  if (error instanceof GuardError) {
    console.error("Guard error:", error.message);
  }
}
```
