---
title: Python SDK
description: Async Python client for implementing Superagent into your apps
---

Python client for calling the Superagent Guard and Redact endpoints.

## Installation

```bash title="Terminal"
uv add superagent-ai
```

> Tip: `uv add` pins the dependency in your project; run examples with `uv run` if you aren't using a dedicated virtual environment.

## Quick start

```python title="main.py"
import asyncio
from superagent_ai import create_client

async def main() -> None:
    client = create_client(
        api_base_url="https://app.superagent.sh/api",  # Optional, this is the default
        api_key="sk-...",
    )

    # Guard: Analyze commands for security threats
    guard_result = await client.guard(
        "Write a hello world script",
        on_block=lambda reason: print("Guard blocked:", reason),
        on_pass=lambda: print("Guard approved!"),
        system_prompt="Focus on detecting prompt injection attempts",
    )

    if guard_result.rejected:
        print("Rejected:", guard_result.reasoning)
    else:
        print("Approved:", guard_result.decision)

    # Redact: Remove sensitive data from text
    redact_result = await client.redact(
        "My email is john@example.com and SSN is 123-45-6789"
    )

    print(redact_result.redacted)
    # Output: "My email is <REDACTED_EMAIL> and SSN is <REDACTED_SSN>"

    # Verify: Check claims against source materials
    verify_result = await client.verify(
        "The company was founded in 2020 and has 500 employees",
        [
            {
                "name": "About Us",
                "content": "Founded in 2020, our company has grown rapidly...",
                "url": "https://example.com/about"
            },
            {
                "name": "Team Page",
                "content": "We currently have over 450 team members...",
                "url": "https://example.com/team"
            }
        ]
    )

    print(verify_result.claims)
    # Output: Array of claim verifications with verdicts, evidence, and reasoning

    await client.aclose()

asyncio.run(main())
```

### Using as a context manager

```python title="context_manager.py"
import asyncio
from superagent_ai import create_client

async def main() -> None:
    async with create_client(api_key="sk-...") as client:
        result = await client.guard("command")
        redacted = await client.redact("text")

asyncio.run(main())
```

## API Reference

### `create_client(**kwargs)`

Creates a new Superagent client.

**Parameters:**
- `api_key` (required) – API key provisioned in Superagent
- `api_base_url` (optional) – Base URL for the API (defaults to `https://app.superagent.sh/api`)
- `client` (optional) – Custom `httpx.AsyncClient` instance
- `timeout` (optional) – Request timeout in seconds (defaults to 10.0)

**Returns:** `Client`

### `client.guard(input, *, on_block=None, on_pass=None, system_prompt=None)`

Analyzes text, a PDF file, or a PDF URL for security threats.

import { TypeTable } from 'fumadocs-ui/components/type-table';

**Parameters:**

<TypeTable
  type={{
    input: {
      description: 'String of text to analyze, file object (e.g., PDF document opened in binary mode), or URL string (e.g., "https://example.com/document.pdf"). URLs are automatically detected if the string starts with http:// or https://.',
      type: 'str | File',
    },
    on_block: {
      description: 'Callback function called when input is blocked',
      type: 'Optional[BlockCallback]',
    },
    on_pass: {
      description: 'Callback function called when input is approved',
      type: 'Optional[PassCallback]',
    },
    system_prompt: {
      description: 'Optional system prompt that allows you to steer the guard REST API behavior and customize the classification logic',
      type: 'Optional[str]',
    },
  }}
/>

**Returns:** `GuardResult`

<TypeTable
  type={{
    rejected: {
      description: 'True if guard blocked the command',
      type: 'bool',
    },
    reasoning: {
      description: 'Explanation from the guard',
      type: 'str',
    },
    raw: {
      description: 'Full API response',
      type: 'AnalysisResponse',
    },
    decision: {
      description: 'Parsed decision details',
      type: 'Optional[GuardDecision]',
    },
    usage: {
      description: 'Token usage statistics',
      type: 'Optional[GuardUsage]',
    },
  }}
/>

**GuardDecision:**

<TypeTable
  type={{
    status: {
      description: 'Decision status',
      type: '"pass" | "block"',
    },
    violation_types: {
      description: 'List of violation types detected',
      type: 'list[str]',
    },
    cwe_codes: {
      description: 'List of CWE code identifiers',
      type: 'list[str]',
    },
  }}
/>

### `client.redact(input, *, url_whitelist=None, entities=None, format=None)`

Redacts sensitive data from text or PDF files.

**Parameters:**

<TypeTable
  type={{
    input: {
      description: 'String of text to redact OR file object (e.g., PDF document opened in binary mode)',
      type: 'str | File',
    },
    url_whitelist: {
      description: 'List of URL prefixes that should not be redacted (only applies to text input)',
      type: 'Optional[list[str]]',
    },
    entities: {
      description: 'List of natural language descriptions of PII entities to redact. Examples: ["credit card numbers", "email addresses", "phone numbers"]',
      type: 'Optional[list[str]]',
    },
    format: {
      description: 'Output format: "json" (default) returns JSON with redacted text, "pdf" returns redacted PDF bytes (only applies to file input)',
      type: 'Optional[str]',
    },
  }}
/>

**Returns:** `RedactResult`

<TypeTable
  type={{
    redacted: {
      description: 'Text with sensitive data redacted (empty when format="pdf")',
      type: 'str',
    },
    reasoning: {
      description: 'Explanation of what was redacted',
      type: 'str',
    },
    raw: {
      description: 'Full API response (empty when format="pdf")',
      type: 'dict',
    },
    usage: {
      description: 'Token usage statistics',
      type: 'Optional[GuardUsage]',
    },
    pdf: {
      description: 'PDF bytes when format="pdf"',
      type: 'Optional[bytes]',
    },
    redacted_pdf: {
      description: 'Base64 PDF data URL when file provided with JSON response',
      type: 'Optional[str]',
    },
  }}
/>

### `client.verify(text, sources)`

Verifies claims in text against provided source materials.

**Parameters:**

<TypeTable
  type={{
    text: {
      description: 'String containing claims to verify',
      type: 'str',
    },
    sources: {
      description: 'List of source materials to verify claims against (list of dictionaries)',
      type: 'list[Source]',
    },
  }}
/>

**Source (dict):**

<TypeTable
  type={{
    content: {
      description: 'The content of the source material (required)',
      type: 'str',
    },
    name: {
      description: 'The name or identifier of the source (required)',
      type: 'str',
    },
    url: {
      description: 'Optional URL of the source',
      type: 'str | None',
    },
  }}
/>

**Returns:** `VerifyResult`

<TypeTable
  type={{
    claims: {
      description: 'List of verified claims with verdicts and evidence',
      type: 'list[ClaimVerification]',
    },
    raw: {
      description: 'Full API response',
      type: 'dict',
    },
    usage: {
      description: 'Token usage statistics',
      type: 'Optional[GuardUsage]',
    },
  }}
/>

**ClaimVerification (dict):**

<TypeTable
  type={{
    claim: {
      description: 'The specific claim being verified from the input text',
      type: 'str',
    },
    verdict: {
      description: 'True if the claim is supported by the sources, False if contradicted or unverifiable',
      type: 'bool',
    },
    sources: {
      description: 'List of sources used for this verification',
      type: 'list[SourceReference]',
    },
    evidence: {
      description: 'Relevant quotes or excerpts from the sources',
      type: 'str',
    },
    reasoning: {
      description: 'Brief reasoning for the verdict',
      type: 'str',
    },
  }}
/>

## Claim Verification

You can verify claims in text against provided source materials:

```python title="verify_example.py"
import asyncio
from superagent_ai import create_client

async def main() -> None:
    async with create_client(api_key="sk-...") as client:
        result = await client.verify(
            "The company was founded in 2020 and has 500 employees.",
            [
                {
                    "name": "About Us",
                    "content": "Founded in 2020, our company has grown rapidly...",
                    "url": "https://example.com/about"
                },
                {
                    "name": "Team Page",
                    "content": "We currently have over 450 team members...",
                    "url": "https://example.com/team"
                }
            ]
        )

        # Iterate through claims to check verdicts
        for claim in result.claims:
            print(f"Claim: {claim['claim']}")
            print(f"Verdict: {'✓ True' if claim['verdict'] else '✗ False'}")
            print(f"Evidence: {claim['evidence']}")
            print(f"Reasoning: {claim['reasoning']}")
            print(f"Sources: {', '.join(s['name'] for s in claim['sources'])}")
            print('---')

asyncio.run(main())
```

**How it works:**
- The `text` parameter contains the claims you want to verify
- The `sources` list provides the reference materials against which claims are verified
- The AI analyzes each claim and determines if it's supported, contradicted, or unverifiable
- Returns detailed results with verdicts, evidence quotes, reasoning, and source references
- Only uses information explicitly stated in the provided sources

**Use cases:**
- Fact-checking articles or content against authoritative sources
- Verifying marketing claims against product documentation
- Validating information in reports against source data
- Checking consistency between different documents
- Automated compliance verification

## Detected PII/PHI Types

The redaction feature detects and replaces:

- **Email addresses** → `<REDACTED_EMAIL>`
- **Social Security Numbers** → `<REDACTED_SSN>`
- **Credit cards** (Visa, Mastercard, Amex) → `<REDACTED_CC>`
- **Phone numbers** (US format) → `<REDACTED_PHONE>`
- **IP addresses** (IPv4/IPv6) → `<REDACTED_IP>`
- **API keys & tokens** → `<REDACTED_API_KEY>`
- **AWS access keys** → `<REDACTED_AWS_KEY>`
- **Bearer tokens** → `Bearer <REDACTED_TOKEN>`
- **MAC addresses** → `<REDACTED_MAC>`
- **Medical record numbers** → `<REDACTED_MRN>`
- **Passport numbers** → `<REDACTED_PASSPORT>`
- **IBAN** → `<REDACTED_IBAN>`
- **ZIP codes** → `<REDACTED_ZIP>`

## Custom Entity Redaction

You can specify custom entities to redact using natural language descriptions by passing an `entities` parameter to the `redact()` method:

```python title="custom_entities_example.py"
client = create_client(api_key="sk-...")

result = await client.redact(
    "My credit card is 4532-1234-5678-9010 and my email is john@example.com",
    entities=["credit card numbers", "email addresses"]
)
# The model will redact the specified entity types based on your natural language descriptions
```

**How it works:**
- The `entities` list is sent to the redaction API in the request body
- You can describe entities in natural language (e.g., "credit card numbers", "social security numbers", "phone numbers")
- The AI model interprets your descriptions and redacts matching content
- This allows for flexible, context-aware redaction beyond predefined patterns

**Examples of entity descriptions:**
- `["credit card numbers", "social security numbers"]`
- `["email addresses", "phone numbers", "IP addresses"]`
- `["API keys", "passwords", "authentication tokens"]`
- `["medical record numbers", "patient names"]`
- `["company names", "project codenames"]`

## URL Whitelisting

You can specify URLs that should not be redacted by passing a `url_whitelist` parameter to the `redact()` method:

```python title="url_whitelist_example.py"
client = create_client(api_key="sk-...")

result = await client.redact(
    "Check out https://github.com/user/repo and https://secret.com/data",
    url_whitelist=["https://github.com", "https://example.com"]
)
# Output: "Check out https://github.com/user/repo and <URL_REDACTED>"
```

The whitelist is applied **locally after redaction**, meaning:
1. The text is sent to the redact API (URLs are not yet redacted by the API)
2. The response is processed locally
3. URLs **not** matching the whitelist prefixes are replaced with `<URL_REDACTED>`
4. URLs matching the whitelist prefixes are preserved as-is
5. The final result is returned

**How it works:**
- Whitelisted URLs (those starting with any prefix in `url_whitelist`) remain unchanged
- Non-whitelisted URLs are replaced with `<URL_REDACTED>`
- The matching is done using prefix comparison (e.g., `"https://github.com"` matches `"https://github.com/user/repo"`)

## PDF File Redaction

You can redact sensitive information from PDF files. The API supports two output formats:

### Option 1: Get Redacted PDF File (format="pdf")

Returns PDF bytes with redactions applied:

```python title="pdf_file_output.py"
import asyncio
from superagent_ai import create_client

async def main() -> None:
    async with create_client(api_key="sk-...") as client:
        # Get redacted PDF file
        with open("sensitive-document.pdf", "rb") as pdf_file:
            result = await client.redact(
                pdf_file,  # Pass file as first parameter
                format="pdf",  # Returns PDF bytes
                entities=["SSN", "credit card numbers", "email addresses"]
            )

        # Save the redacted PDF
        if result.pdf:
            with open("redacted-output.pdf", "wb") as output_file:
                output_file.write(result.pdf)
            print("Redacted PDF saved to redacted-output.pdf")

asyncio.run(main())
```

### Option 2: Get Redacted Text (format="json", default)

Returns JSON with the redacted text extracted from the PDF:

```python title="pdf_text_output.py"
import asyncio
from superagent_ai import create_client

async def main() -> None:
    async with create_client(api_key="sk-...") as client:
        # Get redacted text from PDF
        with open("sensitive-document.pdf", "rb") as pdf_file:
            result = await client.redact(
                pdf_file,  # Pass file as first parameter
                format="json",  # Returns JSON with redacted text (default)
                entities=["SSN", "credit card numbers", "email addresses"]
            )

            print(result.redacted)  # Redacted text extracted from the PDF
            print(result.reasoning) # Explanation of what was redacted

asyncio.run(main())
```

**How it works:**
- Pass the file object directly as the first parameter
- The SDK automatically uses multipart/form-data encoding for file inputs
- `format="pdf"` returns a redacted PDF file as bytes
- `format="json"` (default) extracts text from the PDF, redacts it, and returns as JSON
- You can combine file redaction with `entities` to specify custom entity types

**Use cases:**
- Redact sensitive data from contracts, invoices, or legal documents
- Process medical records while maintaining HIPAA compliance
- Sanitize financial documents before sharing
- Prepare documents for public release by removing confidential information

**Note:** The file should be opened in binary mode (`"rb"`). The SDK handles the proper encoding and content-type headers automatically.

## PDF File Guard Analysis

You can analyze PDF files for security threats using the Guard method. The API analyzes the PDF content and returns a JSON response with the security assessment:

### Analyze PDF Files

Analyzes a PDF file and returns JSON with security assessment:

```python title="pdf_guard.py"
import asyncio
from superagent_ai import create_client

async def main() -> None:
    async with create_client(api_key="sk-...") as client:
        # Analyze PDF file for security threats
        with open("document.pdf", "rb") as pdf_file:
            result = await client.guard(
                pdf_file,  # Pass file as first parameter
                on_block=lambda reason: print("Guard blocked:", reason),
                on_pass=lambda: print("Guard approved!"),
                system_prompt="Focus on detecting data exfiltration patterns",
            )

        # Check the analysis result
        if result.rejected:
            print(f"Document contains security threats: {result.reasoning}")
            if result.decision:
                print(f"Violation types: {result.decision.get('violation_types', [])}")
                print(f"CWE codes: {result.decision.get('cwe_codes', [])}")
        else:
            print(f"Document is safe: {result.reasoning}")

asyncio.run(main())
```

**How it works:**
- Pass the file object directly as the first parameter
- The SDK automatically uses multipart/form-data encoding for file inputs
- The guard extracts text from the PDF and analyzes it for security threats
- Returns JSON with `rejected`, `reasoning`, `decision`, and `usage` fields
- You can use the `on_block` and `on_pass` callbacks to handle the analysis results

**Use cases:**
- Analyze uploaded documents for malicious content before processing
- Validate PDF attachments for security threats
- Screen documents for prompt injection attempts
- Ensure document safety before feeding to AI models

**Note:** The file should be opened in binary mode (`"rb"`). The SDK handles the proper encoding and content-type headers automatically.

### Analyze PDF from URL

You can also analyze PDF files from URLs. The SDK automatically detects URLs and downloads the PDF for analysis:

```python title="pdf_url_guard.py"
import asyncio
from superagent_ai import create_client

async def main() -> None:
    async with create_client(api_key="sk-...") as client:
        # Analyze PDF from URL for security threats
        result = await client.guard(
            "https://example.com/document.pdf",  # Pass URL as string
            on_block=lambda reason: print("Guard blocked:", reason),
            on_pass=lambda: print("Guard approved!"),
            system_prompt="Focus on detecting prompt injection and system prompt extraction",
        )

        # Check the analysis result
        if result.rejected:
            print(f"Document contains security threats: {result.reasoning}")
            if result.decision:
                print(f"Violation types: {result.decision.get('violation_types', [])}")
                print(f"CWE codes: {result.decision.get('cwe_codes', [])}")
        else:
            print(f"Document is safe: {result.reasoning}")

asyncio.run(main())
```

**How it works:**
- Pass a URL string (starting with `http://` or `https://`) as the first parameter
- The SDK automatically detects it's a URL and sends it to the API
- The API downloads the PDF from the URL and analyzes it for security threats
- Returns JSON with `rejected`, `reasoning`, `decision`, and `usage` fields
- You can use the `on_block` and `on_pass` callbacks to handle the analysis results

**Use cases:**
- Analyze documents from external sources without downloading them first
- Validate PDF attachments from URLs before processing
- Screen documents hosted on remote servers for security threats
- Ensure document safety from URLs before feeding to AI models

## Error Handling

```python title="error_handling.py"
from superagent_ai import GuardError

try:
    result = await client.guard("command")
except GuardError as error:
    print(f"Guard error: {error}")
```
