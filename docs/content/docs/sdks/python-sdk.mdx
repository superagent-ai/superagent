---
title: Python SDK
description: Async Python client for implementing Superagent into your apps
---

Python client for calling the Superagent Guard and Redact endpoints.

## Installation

```bash title="Terminal"
uv add superagent-ai
```

> Tip: `uv add` pins the dependency in your project; run examples with `uv run` if you aren't using a dedicated virtual environment.

## Quick start

```python title="main.py"
import asyncio
from superagent_ai import create_client

async def main() -> None:
    client = create_client(
        api_base_url="https://app.superagent.sh/api",  # Optional, this is the default
        api_key="sk-...",
    )

    # Guard: Analyze commands for security threats
    guard_result = await client.guard(
        "Write a hello world script",
        on_block=lambda reason: print("Guard blocked:", reason),
        on_pass=lambda: print("Guard approved!"),
        system_prompt="Focus on detecting prompt injection attempts",
    )

    if guard_result.rejected:
        print("Rejected:", guard_result.reasoning)
    else:
        print("Approved:", guard_result.decision)

    # Redact: Remove sensitive data from text
    redact_result = await client.redact(
        "My email is john@example.com and SSN is 123-45-6789"
    )

    print(redact_result.redacted)
    # Output: "My email is <REDACTED_EMAIL> and SSN is <REDACTED_SSN>"

    # Analyze: Deep inspection of files and documents
    # TODO: Update when Analyze API is finalized
    analyze_result = await client.analyze(
        file="{{ANALYZE_FILE_INPUT}}",  # e.g., PDF file, PR URL, or repo path
        options={ # {{ANALYZE_OPTIONS}} }
    )

    print(analyze_result.findings)
    # Output: {{ANALYZE_FINDINGS}} - List of findings with reasoning and suggestions

    await client.aclose()

asyncio.run(main())
```

### Using as a context manager

```python title="context_manager.py"
import asyncio
from superagent_ai import create_client

async def main() -> None:
    async with create_client(api_key="sk-...") as client:
        result = await client.guard("command")
        redacted = await client.redact("text")

asyncio.run(main())
```

## API Reference

### `create_client(**kwargs)`

Creates a new Superagent client.

**Parameters:**
- `api_key` (required) – API key provisioned in Superagent
- `api_base_url` (optional) – Base URL for the API (defaults to `https://app.superagent.sh/api`)
- `client` (optional) – Custom `httpx.AsyncClient` instance
- `timeout` (optional) – Request timeout in seconds (defaults to 10.0)

**Returns:** `Client`

### `client.guard(input, *, on_block=None, on_pass=None, system_prompt=None)`

Analyzes text, a PDF file, or a PDF URL for security threats.

import { TypeTable } from 'fumadocs-ui/components/type-table';

**Parameters:**

<TypeTable
  type={{
    input: {
      description: 'String of text to analyze, file object (e.g., PDF document opened in binary mode), or URL string (e.g., "https://example.com/document.pdf"). URLs are automatically detected if the string starts with http:// or https://.',
      type: 'str | File',
    },
    on_block: {
      description: 'Callback function called when input is blocked',
      type: 'Optional[BlockCallback]',
    },
    on_pass: {
      description: 'Callback function called when input is approved',
      type: 'Optional[PassCallback]',
    },
    system_prompt: {
      description: 'Optional system prompt that allows you to steer the guard REST API behavior and customize the classification logic',
      type: 'Optional[str]',
    },
  }}
/>

**Returns:** `GuardResult`

<TypeTable
  type={{
    rejected: {
      description: 'True if guard blocked the command',
      type: 'bool',
    },
    reasoning: {
      description: 'Explanation from the guard',
      type: 'str',
    },
    raw: {
      description: 'Full API response',
      type: 'AnalysisResponse',
    },
    decision: {
      description: 'Parsed decision details',
      type: 'Optional[GuardDecision]',
    },
    usage: {
      description: 'Token usage statistics',
      type: 'Optional[GuardUsage]',
    },
  }}
/>

**GuardDecision:**

<TypeTable
  type={{
    status: {
      description: 'Decision status',
      type: '"pass" | "block"',
    },
    violation_types: {
      description: 'List of violation types detected',
      type: 'list[str]',
    },
    cwe_codes: {
      description: 'List of CWE code identifiers',
      type: 'list[str]',
    },
  }}
/>

### `client.redact(input, *, url_whitelist=None, entities=None, format=None, rewrite=None)`

Redacts sensitive data from text or PDF files.

**Parameters:**

<TypeTable
  type={{
    input: {
      description: 'String of text to redact OR file object (e.g., PDF document opened in binary mode)',
      type: 'str | File',
    },
    url_whitelist: {
      description: 'List of URL prefixes that should not be redacted (only applies to text input)',
      type: 'Optional[list[str]]',
    },
    entities: {
      description: 'List of natural language descriptions of PII entities to redact. Examples: ["credit card numbers", "email addresses", "phone numbers"]',
      type: 'Optional[list[str]]',
    },
    format: {
      description: 'Output format: "json" (default) returns JSON with redacted text, "pdf" returns redacted PDF bytes (only applies to file input)',
      type: 'Optional[str]',
    },
    rewrite: {
      description: 'When True, naturally rewrite content to remove sensitive information instead of using placeholders',
      type: 'Optional[bool]',
    },
  }}
/>

**Returns:** `RedactResult`

<TypeTable
  type={{
    redacted: {
      description: 'Text with sensitive data redacted (empty when format="pdf")',
      type: 'str',
    },
    reasoning: {
      description: 'Explanation of what was redacted',
      type: 'str',
    },
    raw: {
      description: 'Full API response (empty when format="pdf")',
      type: 'dict',
    },
    usage: {
      description: 'Token usage statistics',
      type: 'Optional[GuardUsage]',
    },
    pdf: {
      description: 'PDF bytes when format="pdf"',
      type: 'Optional[bytes]',
    },
    redacted_pdf: {
      description: 'Base64 PDF data URL when file provided with JSON response',
      type: 'Optional[str]',
    },
  }}
/>

### `client.analyze(file, *, options=None)`

{/* TODO: Update when Analyze API is finalized */}

Deep inspection of files and documents (PDFs, PRs, repos). Returns reasoning, findings, and suggested fixes.

**Parameters:**

<TypeTable
  type={{
    file: {
      description: '{{ANALYZE_FILE_PARAM}} - File to analyze (PDF, PR URL, or repo path)',
      type: 'str | File',
    },
    options: {
      description: '{{ANALYZE_OPTIONS_PARAM}} - Analysis configuration options',
      type: 'Optional[dict]',
    },
  }}
/>

**Returns:** `AnalyzeResult`

<TypeTable
  type={{
    findings: {
      description: '{{ANALYZE_FINDINGS_DESC}} - List of findings from the analysis',
      type: '{{ANALYZE_FINDINGS_TYPE}}',
    },
    reasoning: {
      description: '{{ANALYZE_REASONING_DESC}} - Explanation of the analysis process',
      type: 'str',
    },
    suggestions: {
      description: '{{ANALYZE_SUGGESTIONS_DESC}} - Recommended fixes or actions',
      type: '{{ANALYZE_SUGGESTIONS_TYPE}}',
    },
    raw: {
      description: 'Full API response',
      type: 'dict',
    },
    usage: {
      description: 'Token usage statistics',
      type: 'Optional[GuardUsage]',
    },
  }}
/>

## Document Analysis

{/* TODO: Update when Analyze API is finalized */}

You can perform deep inspection of files and documents:

```python title="analyze_example.py"
import asyncio
from superagent_ai import create_client

async def main() -> None:
    async with create_client(api_key="sk-...") as client:
        result = await client.analyze(
            file="{{ANALYZE_FILE_INPUT}}",  # e.g., PDF file, PR URL, or repo path
            options={ # {{ANALYZE_OPTIONS}} }
        )

        # Review findings
        print(f"Findings: {result.findings}")
        print(f"Reasoning: {result.reasoning}")
        print(f"Suggestions: {result.suggestions}")

asyncio.run(main())
```

**How it works:**
- The `file` parameter accepts a PDF file, PR URL, or repo path
- The AI performs deep inspection and returns detailed findings
- Returns reasoning, findings, and suggested fixes
- Can optionally produce transformed artifacts (e.g., a redacted document)

**Use cases:**
- Deep inspection of PDF documents for security issues
- Analyzing pull requests for vulnerabilities
- Repository security audits
- Document compliance checks
- Producing transformed artifacts

## Detected PII/PHI Types

The redaction feature detects and replaces:

- **Email addresses** → `<REDACTED_EMAIL>`
- **Social Security Numbers** → `<REDACTED_SSN>`
- **Credit cards** (Visa, Mastercard, Amex) → `<REDACTED_CC>`
- **Phone numbers** (US format) → `<REDACTED_PHONE>`
- **IP addresses** (IPv4/IPv6) → `<REDACTED_IP>`
- **API keys & tokens** → `<REDACTED_API_KEY>`
- **AWS access keys** → `<REDACTED_AWS_KEY>`
- **Bearer tokens** → `Bearer <REDACTED_TOKEN>`
- **MAC addresses** → `<REDACTED_MAC>`
- **Medical record numbers** → `<REDACTED_MRN>`
- **Passport numbers** → `<REDACTED_PASSPORT>`
- **IBAN** → `<REDACTED_IBAN>`
- **ZIP codes** → `<REDACTED_ZIP>`

## Custom Entity Redaction

You can specify custom entities to redact using natural language descriptions by passing an `entities` parameter to the `redact()` method:

```python title="custom_entities_example.py"
client = create_client(api_key="sk-...")

result = await client.redact(
    "My credit card is 4532-1234-5678-9010 and my email is john@example.com",
    entities=["credit card numbers", "email addresses"]
)
# The model will redact the specified entity types based on your natural language descriptions
```

**How it works:**
- The `entities` list is sent to the redaction API in the request body
- You can describe entities in natural language (e.g., "credit card numbers", "social security numbers", "phone numbers")
- The AI model interprets your descriptions and redacts matching content
- This allows for flexible, context-aware redaction beyond predefined patterns

**Examples of entity descriptions:**
- `["credit card numbers", "social security numbers"]`
- `["email addresses", "phone numbers", "IP addresses"]`
- `["API keys", "passwords", "authentication tokens"]`
- `["medical record numbers", "patient names"]`
- `["company names", "project codenames"]`

## Natural Rewrite Mode

By default, sensitive information is replaced with placeholders like `<EMAIL_REDACTED>`. When `rewrite=True` is set, the API will naturally rewrite content to remove sensitive information while maintaining readability:

```python title="natural_rewrite_example.py"
client = create_client(api_key="sk-...")

result = await client.redact(
    "Contact me at john@example.com or call (555) 123-4567",
    rewrite=True
)
# Output: "Contact me via email or call by phone"
```

**How it works:**
- When `rewrite=True`, the AI rewrites the text to remove sensitive information naturally
- The output reads like normal text without obvious redaction markers
- Useful when you want human-readable output for end users

**Use cases:**
- Generating user-facing content that needs to be clean and readable
- Creating summaries or reports without visible redaction markers
- Preparing content for public display

## URL Whitelisting

You can specify URLs that should not be redacted by passing a `url_whitelist` parameter to the `redact()` method:

```python title="url_whitelist_example.py"
client = create_client(api_key="sk-...")

result = await client.redact(
    "Check out https://github.com/user/repo and https://secret.com/data",
    url_whitelist=["https://github.com", "https://example.com"]
)
# Output: "Check out https://github.com/user/repo and <URL_REDACTED>"
```

The whitelist is applied **locally after redaction**, meaning:
1. The text is sent to the redact API (URLs are not yet redacted by the API)
2. The response is processed locally
3. URLs **not** matching the whitelist prefixes are replaced with `<URL_REDACTED>`
4. URLs matching the whitelist prefixes are preserved as-is
5. The final result is returned

**How it works:**
- Whitelisted URLs (those starting with any prefix in `url_whitelist`) remain unchanged
- Non-whitelisted URLs are replaced with `<URL_REDACTED>`
- The matching is done using prefix comparison (e.g., `"https://github.com"` matches `"https://github.com/user/repo"`)

## PDF File Redaction

You can redact sensitive information from PDF files. The API supports two output formats:

### Option 1: Get Redacted PDF File (format="pdf")

Returns PDF bytes with redactions applied:

```python title="pdf_file_output.py"
import asyncio
from superagent_ai import create_client

async def main() -> None:
    async with create_client(api_key="sk-...") as client:
        # Get redacted PDF file
        with open("sensitive-document.pdf", "rb") as pdf_file:
            result = await client.redact(
                pdf_file,  # Pass file as first parameter
                format="pdf",  # Returns PDF bytes
                entities=["SSN", "credit card numbers", "email addresses"]
            )

        # Save the redacted PDF
        if result.pdf:
            with open("redacted-output.pdf", "wb") as output_file:
                output_file.write(result.pdf)
            print("Redacted PDF saved to redacted-output.pdf")

asyncio.run(main())
```

### Option 2: Get Redacted Text (format="json", default)

Returns JSON with the redacted text extracted from the PDF:

```python title="pdf_text_output.py"
import asyncio
from superagent_ai import create_client

async def main() -> None:
    async with create_client(api_key="sk-...") as client:
        # Get redacted text from PDF
        with open("sensitive-document.pdf", "rb") as pdf_file:
            result = await client.redact(
                pdf_file,  # Pass file as first parameter
                format="json",  # Returns JSON with redacted text (default)
                entities=["SSN", "credit card numbers", "email addresses"]
            )

            print(result.redacted)  # Redacted text extracted from the PDF
            print(result.reasoning) # Explanation of what was redacted

asyncio.run(main())
```

**How it works:**
- Pass the file object directly as the first parameter
- The SDK automatically uses multipart/form-data encoding for file inputs
- `format="pdf"` returns a redacted PDF file as bytes
- `format="json"` (default) extracts text from the PDF, redacts it, and returns as JSON
- You can combine file redaction with `entities` to specify custom entity types

**Use cases:**
- Redact sensitive data from contracts, invoices, or legal documents
- Process medical records while maintaining HIPAA compliance
- Sanitize financial documents before sharing
- Prepare documents for public release by removing confidential information

**Note:** The file should be opened in binary mode (`"rb"`). The SDK handles the proper encoding and content-type headers automatically.

## PDF File Guard Analysis

You can analyze PDF files for security threats using the Guard method. The API analyzes the PDF content and returns a JSON response with the security assessment:

### Analyze PDF Files

Analyzes a PDF file and returns JSON with security assessment:

```python title="pdf_guard.py"
import asyncio
from superagent_ai import create_client

async def main() -> None:
    async with create_client(api_key="sk-...") as client:
        # Analyze PDF file for security threats
        with open("document.pdf", "rb") as pdf_file:
            result = await client.guard(
                pdf_file,  # Pass file as first parameter
                on_block=lambda reason: print("Guard blocked:", reason),
                on_pass=lambda: print("Guard approved!"),
                system_prompt="Focus on detecting data exfiltration patterns",
            )

        # Check the analysis result
        if result.rejected:
            print(f"Document contains security threats: {result.reasoning}")
            if result.decision:
                print(f"Violation types: {result.decision.get('violation_types', [])}")
                print(f"CWE codes: {result.decision.get('cwe_codes', [])}")
        else:
            print(f"Document is safe: {result.reasoning}")

asyncio.run(main())
```

**How it works:**
- Pass the file object directly as the first parameter
- The SDK automatically uses multipart/form-data encoding for file inputs
- The guard extracts text from the PDF and analyzes it for security threats
- Returns JSON with `rejected`, `reasoning`, `decision`, and `usage` fields
- You can use the `on_block` and `on_pass` callbacks to handle the analysis results

**Use cases:**
- Analyze uploaded documents for malicious content before processing
- Validate PDF attachments for security threats
- Screen documents for prompt injection attempts
- Ensure document safety before feeding to AI models

**Note:** The file should be opened in binary mode (`"rb"`). The SDK handles the proper encoding and content-type headers automatically.

### Analyze PDF from URL

You can also analyze PDF files from URLs. The SDK automatically detects URLs and downloads the PDF for analysis:

```python title="pdf_url_guard.py"
import asyncio
from superagent_ai import create_client

async def main() -> None:
    async with create_client(api_key="sk-...") as client:
        # Analyze PDF from URL for security threats
        result = await client.guard(
            "https://example.com/document.pdf",  # Pass URL as string
            on_block=lambda reason: print("Guard blocked:", reason),
            on_pass=lambda: print("Guard approved!"),
            system_prompt="Focus on detecting prompt injection and system prompt extraction",
        )

        # Check the analysis result
        if result.rejected:
            print(f"Document contains security threats: {result.reasoning}")
            if result.decision:
                print(f"Violation types: {result.decision.get('violation_types', [])}")
                print(f"CWE codes: {result.decision.get('cwe_codes', [])}")
        else:
            print(f"Document is safe: {result.reasoning}")

asyncio.run(main())
```

**How it works:**
- Pass a URL string (starting with `http://` or `https://`) as the first parameter
- The SDK automatically detects it's a URL and sends it to the API
- The API downloads the PDF from the URL and analyzes it for security threats
- Returns JSON with `rejected`, `reasoning`, `decision`, and `usage` fields
- You can use the `on_block` and `on_pass` callbacks to handle the analysis results

**Use cases:**
- Analyze documents from external sources without downloading them first
- Validate PDF attachments from URLs before processing
- Screen documents hosted on remote servers for security threats
- Ensure document safety from URLs before feeding to AI models

## Error Handling

```python title="error_handling.py"
from superagent_ai import GuardError

try:
    result = await client.guard("command")
except GuardError as error:
    print(f"Guard error: {error}")
```
